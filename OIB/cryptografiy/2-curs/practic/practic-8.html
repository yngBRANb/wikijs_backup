<!--
title: Алгоритм Диффи-Хелмана. Организация алгоритма передачи симметричного ключа
description: Практическая работа №8 
published: true
date: 2025-01-19T10:28:05.878Z
tags: 
editor: ckeditor
dateCreated: 2025-01-19T10:27:04.845Z
-->

<h1 style="text-align:justify;">Цель работы: изучить алгоритм Диффи-Хелмана. Освоить методы генерации больших простых чисел и методы проверки больших чисел на простоту. Научиться строить первообразные корни по модулю n.&nbsp;</h1>
<p style="text-align:justify;">Краткие теоретические и учебно-методические материалы по теме практической работы.&nbsp;</p>
<p style="text-align:justify;"><strong>Генерация большого простого числа.</strong></p>
<p style="text-align:justify;">Любая криптосистема основана на использовании ключей. Если для обеспечения конфиденциального обмена информацией между двумя пользователями процесс обмена ключами тривиален, то в системе,&nbsp; в которой количество пользователей составляет десятки и сотни, управление ключами&nbsp; – серьёзная проблема. Если не обеспечено достаточно надёжное управление ключевой информацией, то, завладев ею, злоумышленник получает неограниченный доступ ко всей информации. В этом случае необходимо введение какой-либо случайной величины в процесс шифрования.</p>
<p style="text-align:justify;">В частности, для реализации алгоритма RSA&nbsp; требуются большие простые числа.&nbsp;</p>
<p style="text-align:justify;"><strong>Считается, что вероятность выбора двумя людьми одного и того же большого простого .числа пренебрежимо мала.</strong></p>
<p style="text-align:justify;">Существуют различные вероятностные проверки чисел на простоту, определяющие с заданной степенью достоверности, является ли число простым. При условии, что эта степень достоверности велика, такие способы достаточно хороши. Такие простые числа часто называют «промышленными простыми», т.е. они просты с контролируемой возможностью ошибки.</p>
<p style="text-align:justify;">&nbsp;В 1976 году американцы Уитфилд Диффи и Мартин Хеллман (Diffi W., Hellman M.) предложили новый принцип построения криптосистем [2]. По их задумке, передачу от Алисы к Бобу сообщения можно было осуществить без передачи ключей, более того, не было необходимости скрывать метод шифрования. Предложенный принцип, в итоге, преобразовался в отдельную классификацию алгоритмов шифрования - шифрование с открытым ключом.</p>
<p style="text-align:justify;">В поисках способов реализовать свою идею, Диффи и Хеллман пришли к использованию односторонних функций, т.е. функций, в которых получить исходное значение практически невозможно. Одна из таких функций в математике – вычисление по модулю . Перейдем к рассмотрению самого алгоритма.</p>
<p style="text-align:justify;">Принцип простой. Сначала Алиса и Боб вместе выбирают большие простые числа&nbsp;n&nbsp;и&nbsp;g&nbsp;так, чтобы работало следующее соотношение:&nbsp;gxmod&nbsp;n. Эти два числа не нужно хранить в секрете, поэтому об использовании этих чисел Алиса и Боб могут договориться как им удобно (даже прийти в гости к Еве и выбрать эти числа при ней). Потом выполняются следующие действия:</p>
<p style="text-align:justify;">1)&nbsp;&nbsp;&nbsp; Алиса выбирает случайное целое большое число&nbsp;x&nbsp;и присылает Бобу число&nbsp;X, полученное по формуле&nbsp;X&nbsp;=&nbsp;&nbsp;gxmod&nbsp;n.</p>
<p style="text-align:justify;">2)&nbsp;&nbsp;&nbsp; Боб выбирает случайно целое большое число&nbsp;y&nbsp;и присылает Алисе число&nbsp;Y, которое считается как&nbsp;Y&nbsp;=&nbsp;gymod&nbsp;n.</p>
<p style="text-align:justify;">3)&nbsp;&nbsp;&nbsp; Алиса вычисляет число&nbsp;k1 =&nbsp;Yxmod&nbsp;n.</p>
<p style="text-align:justify;">4)&nbsp;&nbsp;&nbsp; Боб вычисляет число&nbsp;k2 =&nbsp;Xymod&nbsp;n.</p>
<p style="text-align:justify;">Нетрудно заметить, что и&nbsp;k1, и&nbsp;k2&nbsp;равны&nbsp;gxymod&nbsp;n.&nbsp;Но ни Ева, ни кто-нибудь еще, кто прослушивал канал, не знают этого значения. Им известны только&nbsp;n,&nbsp;g,&nbsp;X&nbsp;и&nbsp;Y. Теоретически, Ева знает функцию и может вычислить&nbsp;k1&nbsp;или&nbsp;k2, но, к сожалению для нее, эта функция является односторонней, и если Алиса и Боб могут выполнить обратное преобразование, поскольку обладают всеми необходимыми числами, то Еве будет очень сложно сделать тоже самое, а учитывая, что работа ведется с большими числами, - почти невозможно.</p>
<p style="text-align:justify;">Есть, конечно, одно «но». Выбор&nbsp;n&nbsp;и&nbsp;g&nbsp;довольно сильно влияет на безопасность системы. Следует выбирать&nbsp;n&nbsp;такое, чтобы&nbsp;(n-1)/2&nbsp;было также простым, и, самое главное, чтобы&nbsp;n&nbsp;было большим: безопасность заключается в сложности разложения на множители чисел того же размера, что и&nbsp;n. Требования к выбору&nbsp;g&nbsp;не такие строгие, главное требование – оно должно быть примитивом&nbsp;mod&nbsp;n. В остальном же, оно может быть хоть одноразрядным простым числом.</p>
<p style="text-align:justify;">Следует добавить, что алгоритм Диффи-Хеллмана успешно работает с тремя и более участниками, секретный ключ, после всех вычислений будет иметь вид&nbsp;k&nbsp;=&nbsp;gn1*n2*…*nNmod&nbsp;n,&nbsp;где&nbsp;n1..nN&nbsp;– переменные, закрепленные за каждым участником (x,y,&nbsp;z&nbsp;и т.д.) [1]. Алгоритм, как видно из заголовка, является алгоритмом обмена ключами, а не шифрования.</p>
<p style="text-align:justify;"><strong>Задание.</strong></p>
<p style="text-align:justify;">Произвести расчет ключа.(Взять p&nbsp;больше 20)</p>
<p style="text-align:justify;">1.Совместно с удалённой стороной устанавливить &nbsp;<i>открытые параметры</i>&nbsp;<i>p</i>&nbsp;и&nbsp;<i>g</i>&nbsp;(обычно значения&nbsp;<i>p</i>&nbsp;и&nbsp;<i>g</i>&nbsp;генерируются на одной стороне и передаются другой), где</p>
<p style="text-align:justify;"><i>p</i>&nbsp;является&nbsp;случайным простым числом</p>
<p style="text-align:justify;"><i>(p-1)/2</i>&nbsp;также должно быть&nbsp;случайным простым числом&nbsp;(для повышения безопасности)<sup>&nbsp;</sup></p>
<p style="text-align:justify;"><i>g</i>&nbsp;является&nbsp;первообразным корнем&nbsp;по модулю&nbsp;<i>p</i></p>
<p style="text-align:justify;">2.Вычислить&nbsp;<i>открытый ключ</i>&nbsp;<i>A</i>, используя преобразование над&nbsp;<i>закрытым ключом</i></p>
<p style="text-align:justify;"><i>A(B) = g<sup>a(b)</sup></i>&nbsp;mod&nbsp;<i>p&nbsp;</i>для каждой стороны (A,&nbsp;a) для одной; (B,&nbsp;b) для другой.</p>
<p style="text-align:justify;">3.Обменяться&nbsp;<i>открытыми ключами</i>&nbsp;с удалённой стороной</p>
<p style="text-align:justify;">4.Вычислить&nbsp;<i>общий секретный ключ</i>&nbsp;<i>K</i>, используя открытый ключ удаленной стороны&nbsp;<i>B</i>&nbsp;и свой закрытый ключ&nbsp;<i>a</i></p>
<p style="text-align:justify;"><i>K = B<sup>a</sup></i>&nbsp;mod&nbsp;<i>p</i></p>
<p style="text-align:justify;"><i>К</i>&nbsp;получается равным с обеих сторон, потому что:</p>
<p style="text-align:justify;"><i>B<sup>a</sup></i>&nbsp;mod&nbsp;<i>p = (g<sup>b</sup></i>&nbsp;mod&nbsp;<i>p)<sup>a</sup></i>&nbsp;mod&nbsp;<i>p =&nbsp;<strong>g<sup>ab</sup></strong></i>&nbsp;<strong>mod&nbsp;</strong><i><strong>p</strong></i>&nbsp;<i>= (g<sup>a</sup></i>&nbsp;mod&nbsp;<i>p)<sup>b</sup></i>&nbsp;mod&nbsp;<i>p = A<sup>b</sup></i>&nbsp;mod&nbsp;<i>p</i></p>
<p style="text-align:justify;">5. Сравнить общие ключи.</p>
<p style="text-align:justify;">&nbsp;</p>
<p style="text-align:justify;"><strong>Контрольные вопросы:</strong></p>
<p style="text-align:justify;">1.Для чего применяется алгоритм Диффи-Хеллмана?</p>
<p style="text-align:justify;">2.Что такое модулярная математика?</p>
<p style="text-align:justify;">3.Чем обеспечивается секретность получаемого ключа?</p>
<p>&nbsp;</p>
