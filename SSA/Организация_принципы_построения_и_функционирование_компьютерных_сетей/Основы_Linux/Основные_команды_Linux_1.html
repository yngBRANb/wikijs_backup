<!--
title: Основные команды Linux 1
description: 
published: true
date: 2025-03-11T04:38:16.774Z
tags: 
editor: ckeditor
dateCreated: 2025-01-18T12:09:47.266Z
-->

<p><strong>Цель работы:</strong> изучить и освоить основные команды Linux.&nbsp;</p>
<h1><span class="text-small"><strong>Краткие теоретические и учебно-методические материалы по теме лабораторной работы:</strong></span></h1>
<h1 style="text-align:center;"><code>- - - <strong>Оболочка Bourne Shell (bash): /bin/sh</strong> - - -</code></h1>
<p>Оболочка (shell) — одна из самых важных частей системы Unix. Это программа, выполняющая команды, которые пользователи вводят в окно терминала. Эти команды могут быть другими программами или встроенными функциями оболочки. Оболочка — это еще и среда программирования. Программисты Unix часто разбивают типичные задачи на более мелкие компоненты и применяют оболочку для управления ими. Многие важные части системы на самом деле являются сценариями (скриптами, shell scripts) оболочки — текстовыми файлами, которые содержат последовательность команд. Если раньше вы работали с системой MS-DOS, вы можете думать о скриптах оболочки как о мощных .BAT-файлах. Существует множество различных оболочек Unix, но все они — производные от оболочки Bourne shell (/bin/sh), стандартной оболочки, разработанной в компании Bell Labs для ранних версий Unix.</p>
<p style="text-align:center;"><code>- - - <strong>Окно оболочки</strong> - - -</code></p>
<p>После входа в систему откройте окно оболочки (часто называется терминалом). Самый простой способ — войти с помощью графического интерфейса, такого как Gnome или KDE, — открыть приложение Terminal, которое запускает оболочку внутри нового окна. После того как вы откроете оболочку, в верхней части окна появится подсказка, которая обычно заканчивается знаком доллара <strong>($)</strong>. Это приглашение должно выглядеть следующим образом: <strong>name@host:path$</strong>, где <strong>name</strong> — ваше имя пользователя, <strong>host</strong> — имя вашей машины, а <strong>path</strong> — текущий рабочий каталог. Все команды начинаются с одного знака <strong>$</strong>, который обозначает приглашение оболочки. Например, наберите следующую команду и нажмите клавишу Enter:</p>
<pre><code class="language-plaintext"> $ echo Hello there</code></pre>
<p>Теперь введите команду:</p>
<pre><code class="language-plaintext"> $ cat /etc/passwd</code></pre>
<p>Она отображает содержимое системного файла /etc/passwd, а затем возвращает приглашение оболочки. Пока не обращайте внимания на вывод команды, что это такое вы узнаете позже. Текст команды обычно начинается с названия программы для запуска и может сопровождаться <strong>аргументами (arguments)</strong>, которые сообщают программе, с чем работать и как именно. В приведенном примере используется программа cat, в нее добавлен один аргумент, /etc/passwd. Многие аргументы являются <strong>параметрами (options)</strong>, которые изменяют поведение программы по умолчанию и обычно начинаются с дефиса (-). Далее это будет показано при описании команды ls. Однако есть исключения, которые не соответствуют этой обычной структуре команд, — встроенные модули оболочки и переменные окружения</p>
<p style="text-align:center;"><code>- - - <strong>Программа cat</strong> - - -</code></p>
<p>Программа cat одна из самых простых для понимания в системах Unix, она просто выводит содержимое одного или нескольких файлов или другого источника ввода. Синтаксис команды cat выглядит следующим образом:</p>
<pre><code class="language-plaintext"> $ cat file1 file2 ...</code></pre>
<p>При выполнении cat выводит содержимое файлов file1, file2 и любых других файлов, указанных в качестве аргументов (в примере это обозначено многоточием ...), а затем завершает работу. Программа называется cat, потому что она выполняет конкатенацию (concatenation, присоединение), когда выводит содержимое нескольких файлов. Существует много способов запустить cat. Изучим процесс ввода-вывода Unix с помощью этой программы.</p>
<p style="text-align:center;"><code>- <strong>Стандартный поток ввода (stdin) и стандартный поток вывода (stdout)</strong> -</code></p>
<p>Процессы Unix используют потоки ввода-вывода (Input/Output, I/O streams) для чтения и записи данных. Они считывают данные из входных потоков и записывают данные в выходные потоки. Сами по себе потоки очень гибкие. Например, источником потока ввода могут быть файл, устройство, окно терминала или даже выходной поток из другого процесса. Чтобы увидеть поток ввода в работе, введите команду cat (без аргументов) и нажмите клавишу Enter. На этот раз вывод появится не сразу, и вы не получите приглашение оболочки, потому что cat все еще работает. Теперь введите что-нибудь и нажмите клавишу Enter в конце каждой строки. Теперь команда cat повторяет любую строку, которую вы вводите. Как только вам это наскучит, нажмите сочетание клавиш Ctrl+D в пустой строке, чтобы завершить команду cat и вернуться к командной строке. Причина, по которой команда cat так сработала, связана с потоками. Если вы не указываете входное имя файла, cat считывает данные из стандартного потока ввода (standard input), предоставляемого ядром Linux, а не из потока, подключенного к файлу. В этом случае стандартный поток ввода подключен к терминалу, где вы запускаете команду cat.</p>
<p><strong>Стандартный поток вывода (standard output)</strong> работает точно так же. Ядро предоставляет каждому процессу стандартный поток вывода, в который процессы могут записывать свои выходные данные. Команда cat всегда записывает свои выходные данные в стандартный поток вывода. При запуске cat в терминале в приведенных ранее примерах стандартный вывод был подключен к этому терминалу, так что именно там отображался вывод. Стандартный ввод и вывод часто сокращают как stdin и stdout соответственно. Многие команды работают так же, как команда cat: если вы не указываете входной файл, команда читает из stdin. Вывод же немного отличается. Некоторые программы (например, cat) отправляют выходные данные только в stdout, но другие имеют возможность отправлять выходные данные непосредственно в файлы. Существует и третий стандартный поток ввода-вывода, называемый стандартной ошибкой (standard error). Одна из самых полезных особенностей стандартных потоков заключается в том, что вы можете легко управлять ими для чтения и записи не только в терминале. В частности, вы узнаете, как подключать потоки к файлам и другим процессам.</p>
<h1 style="text-align:center;"><span class="text-small"><code>- - - <strong>Основные команды (работа с файлами)</strong> - - -</code></span></h1>
<h2><span class="text-small"><strong>Команда ls</strong></span></h2>
<p>Далее представлены наиболее часто используемые команды для взаимодействия с файлами без которых дальнейшее взаимодействие с Linux практически невозможно (далее также представлены и часто используемые аргументы, которые можно использовать с командами).</p>
<pre><code class="language-plaintext">$ ls</code></pre>
<p>Команда ls перечисляет (lists) содержимое каталога. По умолчанию используется текущий каталог, но вы можете добавить любой каталог или файл в качестве аргумента, и для этой операции существует много полезных параметров. Например, применяйте <strong>ls -l</strong> для подробного (long, длинного) списка и <strong>ls -F</strong> для отображения информации о типе файла. Вот пример длинного списка, он включает владельца файла (столбец 3), группу (столбец 4), размер файла (столбец 5) и дату/время изменения (между столбцом 5 и именем файла):</p>
<pre><code class="language-plaintext"> $ ls -l</code></pre>
<figure class="image"><img src="/ssa/baza_linux/practica/baza_1.png"></figure>
<p>Чаще всего используются две комбинации этой команды, та что была показана выше для просмотра подробного описания содержимого папки, например: когда необходимо посмотреть время создания файла, его владельца, выданные права т.д., а также просто команда <strong>ls</strong> для быстрого просмотра содержимого папки, когда нет необходимости в конкретике и просто нужно узнать что находится в папке, вывод команды в таком случае будет следующим:</p>
<pre><code class="language-plaintext">$ ls</code></pre>
<figure class="image"><img src="/ssa/baza_linux/practica/baza_2_1.png"></figure>
<h2><span class="text-small"><strong>Команда cp</strong></span></h2>
<p>В своей простейшей форме команда cp копирует файлы. Например, чтобы скопировать файл file1 в file2, введите следующее:</p>
<pre><code class="language-plaintext">$ cp file1 file2</code></pre>
<p>Вы также можете скопировать файл в другой каталог, сохранив в нем то же имя файла:</p>
<pre><code class="language-plaintext">$ cp file dir</code></pre>
<p>Чтобы скопировать более одного файла в каталог (папку) с именем dir, попробуйте применить команду из следующего примера, которая копирует три файла:</p>
<pre><code class="language-plaintext">$ cp file1 file2 file3 dir</code></pre>
<h2><span class="text-small">Команда mv</span></h2>
<p>Команда mv (move) работает так же, как и команда cp. В своей простейшей форме она переименовывает файл. Например, чтобы переименовать файл file1 в file2, введите следующее:</p>
<pre><code class="language-plaintext">$ mv file1 file2</code></pre>
<p>Можно использовать команду mv для перемещения файлов в другие каталоги таким же образом, что и команду <strong>cp</strong>, но нужно учитывать что в таком случае файл пропадет из того места откуда вы его копируете (в случае с <strong>cp</strong> файл сохранится).</p>
<h2><span class="text-small"><strong>Команда touch&nbsp;</strong></span></h2>
<pre><code class="language-plaintext">$ touch</code></pre>
<p>Команда touch может создать файл. Если целевой файл уже существует, touch не изменяет его, но обновляет временную метку (timestamp) его изменения. Например, чтобы создать пустой файл, введите следующее:</p>
<pre><code class="language-plaintext">$ touch file</code></pre>
<p>Затем запустите в нем команду ls -l. Появится вывод, как в следующем примере, где дата и время указывают, когда была запущена команда touch:</p>
<pre><code class="language-plaintext">$ ls -l file</code></pre>
<figure class="image"><img src="/ssa/baza_linux/practica/baza_2.png"></figure>
<p>Чтобы увидеть обновление метки времени, подождите не менее минуты, а затем снова выполните ту же команду touch. Метка времени, возвращенная из команды ls -l, будет обновлена.</p>
<h2><span class="text-small">Команда rm</span></h2>
<p>Команда rm удаляет (removes) файл. После этого он обычно исчезает из вашей системы и, как правило, не может быть восстановлен, если вы не создали его резервную копию, проще говоря такого понятия как корзина не существует и удаляя что либо вы не сможете это восстановить (за исключением работы в графическом интерфейсе).</p>
<p>Представим что вам необходимо удалить <strong>file</strong> в этом случае используется команда:</p>
<pre><code class="language-plaintext">$ rm file</code></pre>
<p>Однако несмотря на то что команда <strong>rm</strong> предназначена для работы с файлами, если добавить к ней аргументы <strong>-rf</strong> она может удалять и папки (директории):</p>
<pre><code class="language-plaintext">$ rm -rf dir</code></pre>
<h2><span class="text-small"><strong>Команда echo</strong></span></h2>
<pre><code class="language-plaintext">$ echo</code></pre>
<p>Команда echo выводит свои аргументы в стандартный вывод:</p>
<pre><code class="language-plaintext">$ echo Hello again.</code></pre>
<figure class="image"><img src="/ssa/baza_linux/practica/baza_3.png"></figure>
<h2><span class="text-small"><strong>Абсолютные и относительные пути</strong></span></h2>
<p>Вы должны иметь представление об абсолютных и относительных путях в рамках дерева директорий файловой системы. Если вы вводите путь, начинающийся с символа слэша (/), подразумевается, что путь будет указан относительно корневой директории файловой системы. Если же вы не начинаете ввод пути с символа слэша, подразумевается, что точкой отсчета будет текущая директория.</p>
<p>В примере ниже показано, что текущей директорией является директория /home/paul. Для перехода из этой директории в директорию /home вам придется ввести команду cd /home вместо команды cd home.</p>
<figure class="image"><img src="/ssa/baza_linux/practica/baza_4.png"></figure>
<p>При нахождении в директории /home вам придется ввести команду cd paul вместо команды cd /paul для перехода в поддиректорию paul текущей директории /home.</p>
<figure class="image"><img src="/ssa/baza_linux/practica/baza_5.png"></figure>
<p>В том же случае, если вашей текущей директорией является корневая директория /, то и команда cd /home, и команда cd home позволят вам переместиться в директорию /home.</p>
<figure class="image"><img src="/ssa/baza_linux/practica/baza_6.png"></figure>
<p>Этот пример был последним примером, в котором используются команды pwd. С этого момента информация о текущей директории будет всегда выводиться в рамках приглашения командной оболочки. Далее в данной книге будут даны пояснения относительно того, как следует использовать переменную командной оболочки $PS1 для вывода описанной информации.</p>
<h2><span class="text-small"><strong>Завершение путей</strong></span></h2>
<p>Клавиша TAB может помочь избежать ошибок при вводе путей. Нажатие клавиши TAB после ввода части команды cd /et приведет к завершению команды до вида cd /etc/. При этом нажатие клавиши TAB после ввода команды cd /Et не приведет ни к чему, так как была допущена ошибка при вводе части пути (использована буква E в верхнем регистре).</p>
<p>Вам придется нажимать меньше клавиш в случае использования клавиши TAB, к тому же, при использовании этой клавиши вы можете быть уверены в том, что введенный путь является корректным!&nbsp;</p>
<h1 style="text-align:center;"><code>- - - <strong>Основные команды (работа с директориями)</strong> - - -</code></h1>
<p>Далее представлены команды для взаимодействия с каталогами (директориями, папками), а именно о перемещении между ними, создании и удалении.</p>
<p>Иерархия каталогов Unix начинается с каталога <strong>/</strong>, называемого также корневым (root directory). Разделителем каталогов является косая черта (/), но не обратная косая черта (\). Ссылаясь на файл или каталог, вы указываете путь (path) или имя пути (pathname). Путь, начинающийся со знака / (например, /usr/lib), — это полный, или абсолютный путь. Компонент пути, обозначенный двумя точками (..), указывает на то, что это родительский каталог. Например, если вы работаете в каталоге /usr/lib, путь .. ведет к /usr. Аналогично ../bin ведет к /usr/bin. Одна точка (.) относится к текущему каталогу. Например, если вы находитесь в каталоге /usr/lib, путь . по-прежнему ведет к /usr/lib, а путь ./X11 — к каталогу /usr/lib/X11. Нет нужды применять одну точку . очень часто, потому что большинство команд по умолчанию задействуют текущий каталог, если путь не начинается со знака / (поэтому вместо ./X11 можно использовать X11). Путь, не начинающийся с косой черты /, называется относительным. Большую часть времени вы будете работать с относительными путями, потому что уже находитесь в нужном каталоге или рядом с ним. Теперь, когда у вас есть представление об основных механизмах работы с каталогами, перечислим некоторые основные команды каталогов.</p>
<h2><span class="text-small">Команда cd</span></h2>
<p>Текущий рабочий каталог (current working directory) — это каталог, в котором в данный момент находится процесс (например, командная оболочка). В дополнение к командной строке по умолчанию в большинстве дистрибутивов Linux вы можете просмотреть текущий каталог с помощью команды pwd.</p>
<pre><code class="language-plaintext">$ cd dir</code></pre>
<p>Если вы опустите dir, оболочка вернется в ваш домашний каталог (home directory) — первоначальный каталог входа в систему. Некоторые программы обозначают домашний каталог символом ~ (волнистая черта, тильда).</p>
<hr>
<pre><code class="language-plaintext">$ mkdir</code></pre>
<p>Команда mkdir создает новый каталог dir:</p>
<pre><code class="language-plaintext">$ mkdir dir</code></pre>
<hr>
<pre><code class="language-plaintext">$ rmdir</code></pre>
<p>Команда rmdir удаляет каталог dir:</p>
<pre><code class="language-plaintext">$ rmdir dir</code></pre>
<p>Если в каталоге dir есть данные, эта команда не завершается и выводит ошибку. Однако вы можете не захотеть сначала тщательно удалить все файлы и подкаталоги внутри dir. Удаляйте каталог и его содержимое с помощью команды rm -r dir, но будьте осторожны! Это одна из немногих команд, которая способна нанести серьезный ущерб, особенно если вы запускаете ее от имени суперпользователя. Параметр -r указывает на рекурсивное удаление (recursive delete), убирающее все внутри dir. Не применяйте флаг -r с шаблонами поиска, такими как знак звездочки (*). И, конечно же, всегда перепроверяйте команду, прежде чем запускать ее.</p>
